<html xmlns:py="http://genshi.edgewall.org/"
  xmlns:xi="http://www.w3.org/2001/XInclude">
  
  <py:def function="page_title">REST API - Index</py:def>

  <div py:match="content">
    <h2>REST API</h2>

<h3>Introduction</h3>
<p>
CKAN provides a RESTful API.

If you wish to create a software application that uses the CKAN service, then you will need to know which resources are available, what their locations are, what methods each resource supports, and what the responses might be. All this information is available on this page.
</p>

<h3>API Keys</h3>
<p>For any action which makes a change to a resource (i.e. all non-GET methods)
you will require an API key. To obtain your API key:</p>
<ol>
  <li><a href="${h.url_for(controller='user', action=None)}">Login as a normal user</a>.</li>
  <li><a href="${h.url_for(controller='user', action='apikey')}">Visit the API Key page</a>.</li>
</ol>


<h3>Resources and Locations</h3>

<p>A REST interface presents resources at published locations. Here are the names locations of the CKAN REST API resources.
</p>
<table>
<tbody><tr><th> <strong>Resourse Name</strong> </th><th> <strong>Location</strong> 
</th></tr><tr><td> Package Register </td><td> <a href="/api/rest/package">/api/rest/package</a> 

</td></tr><tr><td> Package Entity </td><td> /api/rest/package/PACKAGE-NAME 
</td></tr><tr><td> Group Register </td><td> <a href="/api/rest/package">/api/rest/package</a> 

</td></tr><tr><td> Group Entity </td><td> /api/rest/package/PACKAGE-NAME 
</td></tr><tr><td> Tag Register </td><td> <a href="/api/rest/tag">/api/rest/tag</a> 
</td></tr><tr><td> Tag Entity </td><td> /api/rest/tag/TAG-NAME 
</td></tr><tr><td> Package Search </td><td> /api/search/package
</td></tr></tbody></table>
<h3>Methods and data formats</h3>

<p>Each resource location supports a number of methods, which may send or receive a piece of data. Standard http status codes are used to signal the outcome of the operation.
</p>
<table>
<tbody><tr><th> <strong>Resource</strong> </th><th> <strong>Method</strong> </th><th> <strong>Request</strong> </th><th> <strong>Response</strong>
</th></tr><tr><td> Package Register   </td><td> GET               </td><td></td><td> Package-List      </td><td> 
</td></tr><tr><td> Package Register   </td><td> POST              </td><td> Package           </td><td></td><td>
</td></tr><tr><td> Package Entity      </td><td> GET               </td><td></td><td> Package           </td><td>
</td></tr><tr><td> Package Entity      </td><td> PUT          </td><td> Package           </td><td></td><td>
</td></tr><tr><td> Group Register   </td><td> GET               </td><td></td><td> Group-List      </td><td> 
</td></tr><tr><td> Group Register   </td><td> POST              </td><td> Group           </td><td></td><td>
</td></tr><tr><td> Group Entity      </td><td> GET               </td><td></td><td> Group           </td><td>
</td></tr><tr><td> Group Entity      </td><td> PUT          </td><td> Group           </td><td></td><td>
<!--
</td></tr><tr><td> Package Entity      </td><td> DELETE            </td><td>               </td><td></td><td> 
-->
</td></tr><tr><td> Tag Register       </td><td> GET               </td><td></td><td> Tag-List          </td><td>  
<!--
</td></tr><tr><td> Tag Register       </td><td> POST              </td><td> Tag               </td><td></td><td>  
</td></tr><tr><td> Tag Entity          </td><td> GET               </td><td></td><td> Tag               </td><td> 
</td></tr><tr><td> Tag Entity          </td><td> PUT          </td><td> Tag               </td><td></td><td>  
</td></tr><tr><td> Tag Entity          </td><td> DELETE            </td><td>               </td><td></td><td> 
-->
</td></tr><tr><td> Search      </td><td> GET          </td><td>      </td><td>Search-Response</td><td> 
</td></tr><tr><td> Search      </td><td> POST          </td><td> Query-String           </td><td>Search-Response</td><td>
</td></tr></tbody></table>
<p>
Note: 'PUT' operations may instead use the HTTP POST method.
</p>
<p>
Note: To search, there are two ways to provide parameters - you can use either or both ways in each search request. The first method is to provide them as parameters in the URL, (e.g. /api/rest/search?q=geodata&amp;allfields=1 ) The second way is to encode the parameters as a JSON dictionary and supply them in the POST request.
</p>
<h3>Data Formats</h3>
<table>
<tbody><tr><th> <strong>Name</strong>   </th><th> <strong>Format</strong>                
</th></tr><tr><td> Package-List </td><td> [ Name-String, Name-String, Name-String, ... ] 
</td></tr><tr><td> Package      </td><td> { name: Name-String, title: String, description: String, url: String, download_url: String, tags: Tag-List } 
</td></tr><tr><td> Group-List </td><td> [ Name-String, Name-String, Name-String, ... ] 
</td></tr><tr><td> Group      </td><td> { name: Name-String, title: String, description: String, url: String, download_url: String, tags: Tag-List } 

</td></tr><tr><td> Tag-List     </td><td> [ Name-String, Name-String, Name-String, ... ] 
</td></tr><tr><td> Tag          </td><td> { name: Name-String } 
</td></tr><tr><td> Name-String  </td><td> An alphanumeric string. 
</td></tr><tr><td> Query-String </td><td> [ q: String ]
</td></tr><tr><td> Search-Response </td><td> { count: Count-int, results: [Package-Name-String, Package-Name-String, ... ] } or { count: Count-int, results: [{ name:Name-String, title: String ... }, { name:Name-String, title: String ... }, etc. ] }
</td></tr></tbody></table>

To send request data, create a simple data structure, then convert it to a JSON string, then percent-encode the JSON string, then send it as the request body.

Response data will be in the response body.

<h3>Search parameters</h3>
<table>
<tbody><tr><th> <strong>Key</strong> </th><th> <strong>Value</strong> </th><th> <strong>Example </strong> </th><th> <strong> Notes </strong>         

</th></tr><tr><td> q </td><td> Search-String </td><td> q=geodata </td><td> Criteria to search the package name, title and tags fields for.
</td></tr><tr><td> qjson </td><td> JSON encoded options </td><td> ['q':'geodata']</td><td> All search parameters can be json-encoded and supplied to this URL parameter as a more flexible alternative.
</td></tr><tr><td> title, tags, notes, <br/>groups, author, maintainer </td><td> Search-String </td><td> title=uk%20stat&amp;tags&amp;health+census </td><td> search a particular a field
</td></tr><tr><td> order_by </td><td> field-name (default=name)</td><td> order_by=notes </td><td> Specify the field to sort the results by
</td></tr><tr><td> offset, limit </td><td> result-int (default offset=0, default limit=20)</td><td> offset=40&amp;limit=20</td><td> Pagination options. Offset is the number of the first result and limit is the number of results to return.
</td></tr><tr><td> all_fields </td><td> 0 (default) or 1 </td><td> all_fields=1 </td><td> Each matching search result is given as either a package name (0) or the full package record (1).
</td></tr><tr><td> search_notes </td><td> 0 (default) or 1 </td><td> search_notes=1 </td><td> Specifies search to include the notes field in addition to the default fields.
</td></tr><tr><td> filter_by_openness </td><td> 0 (default) or 1 </td><td> filter_by_openness=1 </td><td> Filters results by ones which are open.
</td></tr><tr><td> filter_by_downloadable </td><td> 0 (default) or 1 </td><td> filter_by_downloadable=1 </td><td> Filters results by ones which have a download URL.
<!--</td></tr><tr><td>  </td><td> </td><td> </td><td>-->
</td></tr></tbody></table>
Note: All search terms are ANDed.

<h3>Status Codes</h3>
<table>
<tbody><tr><th> <strong>Code</strong> </th><th> <strong>Name</strong>         

</th></tr><tr><td> 200        </td><td> OK                 
</td></tr><tr><td> 301        </td><td> Moved Permanently  
</td></tr><tr><td> 400        </td><td> Bad Request     
</td></tr><tr><td> 403        </td><td> Not Authorized     
</td></tr><tr><td> 404        </td><td> Not Found          
</td></tr><tr><td> 409        </td><td> Conflict (e.g. name already exists)
</td></tr><tr><td> 500        </td><td> Service Error           

</td></tr></tbody></table>

<h3>Authorized Requests</h3>
<p>
All requests that are to result in a change to the CKAN register must
be sent with a valid Authorization header. In addition, the user must have the authorization to perform the request.
</p>

<table>
<tbody><tr><th> <strong>Header</strong> </th><th> <strong>Value</strong> 
</th></tr><tr><td>HTTP_AUTHORIZATION</td><td> A valid CKAN REST API authorization token.                 
</td></tr></tbody></table>

<p>
The value passed with this header must satisfy the currently operating requirements of CKAN.
The current requirment for a valid Authorization header is the value should be a valid API key.
</p>

<table>
<tbody><tr><th> <strong>Header</strong> </th><th> <strong>Example Value</strong> 
</th></tr><tr><td>HTTP_AUTHORIZATION</td><td> fde34a3c-b716-4c39-8dc4-881ba115c6d4                 
</td></tr></tbody></table>
<p>
If requests that are required to be authorized are not sent with a currently valid Authorization header, or the user associated with the key is not authorized for the operation, then the requested operation will not be carried out and the CKAN REST API will respond with status code 403.
</p>

</div>

  <xi:include href="../layout.html" />
</html>
